# Домашка 3 недели

## Задание

Бизнес попросил улучшить систему, из-за чего появилось ещё два требования:

- **[US-160]** Разбейте названия заданий [Knowledge Area] Title на knowledge area и title. Это нужно сделать во всех местах, где есть старое название.  
- **[US-170]** Необходимо анонимизировать информацию о менеджерах, чтобы агрессивные кандидаты не могли угрожать несчастным менеджерам.

### Задания домашки

1. Опишите схему события в формате json schema для любого формального и функционального события. На выходе у вас должно получиться две схемы. Если не хотите использовать json schema, можно взять avro.  

2. Опишите процесс миграции четырёх связей. Если у вас нет связи с нужным условием, можно пропустить описание миграции:

    1. Переход формальной синхронной на асинхронную event-driven.  
    2. Переход формальной асинхронной event-driven на синхронную.
    3. Переход функциональной синхронной на асинхронную event-driven.
    4. Переход функциональной асинхронной event-driven на синхронную.  

    _В данном задании достаточно просто описать шаги. Рисунки рисовать не надо и описывать зачем делать каждый из шагов. Хватит простого списка из N шагов где будет описано что и в каком сервисе делается._  

3. Опишите процесс миграции одной формальной и одной функциональной связи для новых требований бизнеса. Стартовой точкой миграции стоит считать уже исправленную связь, т.е. если вы решили использовать формальную event-driven коммуникацию для передачи заданий — описывайте миграцию на новое требование сразу с асинхронной на асинхронную связь.  

    - По итогу должно получиться два описания, одно для формальной или функциональной связи касающейся **[US-160]** и одно для **[US-170]** (какую связь для какого требования выбрать — решайте на свое усмотрение).

    _В данном задании достаточно просто описать шаги. Рисунки рисовать не надо и описывать зачем делать каждый из шагов. Хватит простого списка из N шагов где будет описано что и в каком сервисе делается._  

4. Подготовить описание способов решения проблем вокруг зачисления и списания средств, так как бизнес переживает что что-то пойдет не так и деньги потеряются. Нужно составить список подходов, которые помогут не потерять данные, объяснить почему именно эти подходы нужны и как будут обрабатываться ошибки в случае проблем.

## Решение

### 1. Схемы событий

#### Формальное событие - `CandidateCreated`

```json
{
  "$schema": "https://json-schema.org/draft-04/schema#",

  "title": "CandidateCreated.v0",
  "description": "Initial json schema for Candidate Created formal event",

  "definitions": {
    "payload": {
      "type": "object",
      "properties": {
        "replication_id": { "type": "string" },
        "first_name":     { "type": "string" },
        "last_name":      { "type": "string" },
        "phone_number":   { "type": "string" },
        "email":          { "type": "string" },
        "created_at":     { "type": "string" }
      },
      "required": [
        "replication_id",
        "first_name",
        "last_name",
        "phone_number",
        "email",
        "created_at"
      ]
    }
  },

  "type": "object",

  "properties": {
    "event_id":      { "type": "string" },
    "event_version": { "enum": [0] },
    "event_name":    { "enum": ["CandidateCreated"] },
    "produced_at":   { "type": "string" },
    "payload":       { "$ref": "#/definitions/payload" }
  },

  "required": [
    "event_id",
    "event_version",
    "event_name",
    "produced_at",
    "payload"
  ]
}
```

#### Функциональное событие - `TaskCompletedSuccessfully`

```json
{
  "$schema": "https://json-schema.org/draft-04/schema#",

  "title": "TaskCompletedSuccessfully.v0",
  "description": "Initial json schema for Task Completed Successfully business event",

  "definitions": {
    "payload": {
      "type": "object",
      "properties": {
        "task_solved": {
          "type": "object",
          "properties": {
            "task_replication_id":                    { "type": "string" },
            "title":                                  { "type": "string" },
            "last_updated_by_manager_replication_id": { "type": "string" }
          }
        },
        "solved_by_candidate": {
          "type": "object",
          "properties": {
            "candidate_replication_id": { "type": "string" },
            "first_name":               { "type": "string" },
            "last_name":                { "type": "string" }
          }
        },
        "completed_at": { "type": "string" }
      },
      "required": [
        "task_solved",
        "solved_by_candidate",
        "completed_at"
      ]
    }
  },

  "type": "object",

  "properties": {
    "event_id":      { "type": "string" },
    "event_version": { "enum": [0] },
    "event_name":    { "enum": ["TaskCompletedSuccessfully"] },
    "produced_at":   { "type": "string" },
    "payload":       { "$ref": "#/definitions/payload" }
  },

  "required": [
    "event_id",
    "event_version",
    "event_name",
    "produced_at",
    "payload"
  ]
}
```

### 2. Миграция связей

#### 2.1. Переход формальной синхронной на асинхронную event-driven  

Рассмотрим связь **[COMM-090]**:  
_"Синхронное получение информации о кандидатах в учителя, чтобы назначить задачи."_  

Последовательность шагов, для перехода на асинхронную event-driven коммуникацию:

1. Добавляем новое событие в schema registry (например, схему `CandidateCreated` из задания 1)
2. В сервис "Менеджмента заданий" добавляем консьюмер с бизнес-логикой сохранения информации о кандидатах.  
    - Не забыть написать логику с `ON CONFLICT DO NOTHING`, т.к. синхронная связь все еще на месте.
    - В консьюмере нужно валидировать события из брокера согласно схеме из schema registry (добавленная на шаге 1).
3. Пишем продюсер в сервисе "Найм".
    - Продюсер должен создавать события, соответствующие схеме из schema registry.
4. Если необходимо - собираем дамп из БД "Найм" и накатываем в БД "Менеджмента заданий".
    - Вообще, сервис "Менеджмента заданий", вероятно, уже хранит в себе информацию о Кандидатах, которую он получал из синхронной связи, т.к. ему надо как-то назначать задачи на кандидатов.  
    Решил указать шаг на всякий случай - как я понял из урока, это нужно делать после того, как асинхронная связь уже включена.
5. Выключаем синхронную коммуникацию.  
    Начать, я думаю, надо с сервиса "Менеджмент заданий", т.к. именно он - клиент.  
    - Добавляем фиче флаг в "Менеджмент заданий" - _"звать/не звать Найм для инфы о кандидатах"._  
    По дефолту - получаем данные из брокера.  
    Если после релиза и раскатки асинхронной связи всё ок - можно удалять старый код.
6. Чистим код от старой коммуникации.  
    Если все ок на шаге 5 - удаляем код у клиента ("Менеджмент заданий"), продюсере ("Найм"), документацию на API, итд.

#### 2.2. Переход формальной асинхронной event-driven на синхронную  

Единственная асинхронная связь на изначальной схеме от попугов - **[COMM-060]**:  
_"Отправка события `TaskRating`, чтобы сообщать актуальный рейтинг задачи"._  

Я рассматриваю эту связь как формальную - т.к. в моем понимании это скорее транспорт данных, необходимых для работы бизнес-логики в сервисе "Бонусов", чем результат выполнения бизнес-команды.

Две стратегии итоговой синхронной формальной связи: `push` и `pull`.  
По дефолту, я склоняюсь к стратегии `"pull"`:

- Мы получим максимальную консистеность рейтинга на момент начисления бонуса.
- Напротив, при использовании push-стратегии, меня смущает риск напороться на race condition:
  - Представим ситуацию, что мы пошли начислять бонус;
  - Т.к. рейтинг нам "пушат", то его последнее значение уже лежит у нас в БД;
  - Но прямо пока мы начисляем бонус (транзакция еще открыта) - рейтинг в "Найме" меняется и к нам летит параллельный PUT на рейтинг задания (рейтинг обновляется).
  - В итоге мы взяли не самое актуальное значение рейтинга (косяк).
- Сомневаюсь, что в наших условиях при начислении бонусов за успешное выполнение заданий есть опасность за-DDoS-ить сервис "Найма" на запросах рейтинга.
- Также, чтобы использовать `push`, надо в сервисе "Бонусов" хранить информацию и о Заданиях тоже (дублирование данных, а нужно ли оно?).

С другой стороны, в требованиях указывается проблема **[Problem-030]**: _Логика начисления бонусов некорректна из-за ошибки с рейтингом задания. Во время начисления бонусов во время изменения рейтинга, происходит задержка, которая не удовлетворяет бизнес (нужно моментально)._  
Задержка, на самом деле, может быть вызвана несколькими факторами:

- Например, если мы выбрали стратегию `pull` и таки получаем рейтинг синхронным `GET`-запросом - то поток выполнения в сервисе "Бонусов" будет заблочен на время вызова сервиса "Найм". Задержка? да, но в результате рейтинг будет максимально точный.
- При этом `GET`-запрос при использовании пессимистичных блокировок (а я бы на самом деле только их и использовал) в момент обновления рейтинга может зависнуть и ждать когда транзакция, обновляющая рейтинг, отдаст блокировку.
- Пессимистичная блокировка может точно также сработать и при стратегии `push` - допустим, мы пошли начислять бонус, делаем `select for update` из таблицы с рейтингом задания, а в этот момент запись держит другая транзакция, которая обновляет рейтинг (синхронный `PUT` из сервиса "Найм" в сервис "Бонусов").

Есть еще один вариант, который может помочь c performance (а может и не помочь):

- Выбираем стратегию `push` и начинаем хранить Рейтинг задания прямо в сервисе "Бонусов"
- Чтобы уменьшить "штраф" за использование пессимистичных блокировок - используем оптимистичную блокировку для Рейтинга задания
- Но с ней обязательны **retry** - если-таки мы пойдем начислять бонус когда рейтинг обновился, то транзакция обломится, нужен повтор.
- Но если мы все-таки попадаем на **retry** начисления Бонуса - не "съест" ли он нам весь профит от использования `push` стратегии и оптимистичных блокировок? Pessimistic плохи только при длинных транзакциях.

Вообще, вывод - надо мерять цифры.

- Что происходит чаще - обновляется Рейтинг задания, или начисляется Бонус менеджеру?
- Какая задержка на вызов ендпоинта из сервиса "Найма"?

Так что пока выберу самый тупой вариант - `pull`, синхронным `GET`-ом из сервиса "Бонусов" в сервис "Найма".

1. Добавляем ендпоинт в сервис "Найма" - `GET /tasks/<id>/rating` (может быть можно и целиком ресурс задания отдавать, но возможно без лишних данных будет быстрее).
2. Переписываем бизнес-логику в сервисе "Бонусов" на выполнение `GET`-запроса к сервису "Найма".
3. После релиза и деплоя, отключаем продюсер со стороны сервиса "Найма".
4. Ждем, когда консьюмер в сервисе "Бонусов" дообработает оставшиеся события в топике.
5. Удаляем код консьюмера из сервиса "Бонусов".
6. Можем удалить из сервиса "Бонусов" таблицу с данными, которые собирали из топика.
7. Удаляем топик из брокера.
8. Чистим от остатков коммуникации: документация, метрики на топик, итд.

#### 2.3. Переход функциональной синхронной на асинхронную event-driven

Связь **[COMM-040]**: _Синхронный вызов на зачисление средств._

1. Добавляем событие в schema registry.  
  Схема - в задании 1 "Task Completed Successfully".
2. Добавляем в сервис "Бонусов" пустой консьюмер без бизнес-логики.  
  На текущем этапе - коммуникация все еще старая, синхронная.
3. Пишем продюсер в сервисе "Найма".
  Продюсер должен валидировать событие по схеме из registry.
4. Проверяем, что коммуникация заработала, инфраструктура держит.
5. В сервисе "Бонусов" - переносим бизнес-логику в консьюмер, старую логику (ендпоинт для начисления бонуса) прячем за фиче-тоггл.  
  Если что не так - отключаем фиче-тоггл, консьюмер гасится, синхронный ендпоинт продолжает обрабатывать запросы от сервиса "Найма".
6. Если все ок, чистим систему от старой коммуникации.
  Удаляем код в сервисе "Найма", который синхронно звал начисление бонусов.  
  Документация, тесты, итд.

#### 2.4. Переход функциональной асинхронной event-driven на синхронную

Такой связи на изначальной схеме от попугов я не нашел. Нечего мигрировать.

### 3. Миграция связей для новых требований бизнеса

Цитата из задания: _(какую связь для какого требования выбрать — решайте на свое усмотрение)_

#### 3.1. Новое требование **[US-160]**

**[US-160]**: _Разбейте названия заданий [Knowledge Area] Title на knowledge area и title. Это нужно сделать во всех местах, где есть старое название._  

Для примера я взял связь **[COMM-020]**, с помощью которой сервис "Найма" узнавал о Заданиях из сервиса "Менеджмент заданий".  
Как мы знаем из домашки ко второму уроку, здесь на самом деле две связи, с разными требованиями к консистентности:

- Асинхронная коммуникация для репликации Заданий в момент их создания;
- Синхронная коммуникация для обновления Заданий.

Рассмотрим миграцию **синхронной** связи - вызов `PUT /tasks/<id>` из сервиса "Менеджмента заданий" в сервис "Найма" (т.е. миграция **sync-sync**).

1. В сервисе "Найм" в таблице "Задания" добавляем колонку `knowledge_area`, для `title` будем использовать ту же колонку, что и раньше.
2. Расширяем старый ендпоинт в сервисе "Найм"
    - Добавляем опциональное поле `knowledge_area` (которое пока никто не заполняет)
    - Пишем логику: если поле заполнено, сохранить его в `knowledge_area`
3. Обновляем клиент - сервис "Менеджмента заданий"
    - Задания появляются в этом сервисе, значит этот сервис "знает" как правильно "разложить `title` и `knowledge area`" отдельно друго от друга (звучит тривиально, но в более сложном случае могло бы быть что-то более сложное, например, с походом куда-то наружу, вычислениями, итд).
    - Т.к. консюмер (сервер) готов принимать отдельные поля, пишем код, который начинает слать в API отдельные поля `title` и `knowledge area`.
4. На этом этапе можно взять дамп из сервиса "Менеджмента заданий" и обновить уже сохраненные данные.
5. Когда и клиент и сервер уже оба шлют и ожидают новые данные - можно обновить сервис "Найма" и сделать поле `knowledge_area` обязательным (добавить в схему в список `required` и/или написать валидатор)

Изначально думал применить версионирование, но если честно - не понимаю зачем, если поля не удаляются или не переименовываются.

#### 3.2. Новое требование **[US-170]**

**[US-170]**: _Необходимо анонимизировать информацию о менеджерах, чтобы агрессивные кандидаты не могли угрожать несчастным менеджерам._  

Под анонимизацией я понимаю переход от хранения имени и фамилии (и телефонов, адресов, хз) к использованию `login` строки.

Для примера возьмем связь **[COMM-070]**, с помощью которой сервис "Бонусов" получает информацию о Менеджерах для ведения их финансовых счетов.  
В изначальной схеме эта связь синхронная, по результатам работы на второй неделе я решил переделать ее на асинхронную репликацию данных из сервиса "Менеджмент заданий" в сервис "Бонусов".  
Также я исхожу из предположения что схему БД в сервисе "Менеджмент заданий" уже замигрировали, осталось замигрировать коммуникацию в сервис "Бонусов".

Миграция будет по схеме **async-async**.

0. Добавить нулевую версию события в schema registry.
1. Добавить новое поле `login` в БД сервиса "Бонусов" в таблицу Менеджеров. Пока его никто не заполняет.
2. Добавить новую веврсию схемы события в schema registry.
3. Добавить новый консьюмер для обработки события v1.
4. Отправляем новую версию события из продюсера - сервиса "Менеджмента заданий"
5. Отключаем продюсер для старой версии события.
6. Ждем, когда обработаются все события старой версии из брокера.
7. Удаляем консюмер для старой версии события.
8. Обновляем данные в сервисе "Бонусов" для Менеджеров, созданных старой версией события. Используем дамп из сервиса "Менеджмента заданий".
9. Чистим систему от старой версии события - архивируем схему нулевой версии в registry, документация, тесты.

### 4. Проблемы и обработка ошибок вокруг начисления и списания денег

Начисление бонусов может происходить в одном из двух процессов:

- При создании нового задания менеджером
- При успешном выполнении задания кандидатом

Списание происходит только при неудачном выполнении задания кандидатом.

По результатам работы на второй неделе, коммуникации должны выглядеть следующим образом:

- Начисление бонусов при создании задания должно происходить посредством асинхронной функциональной связи, по бизнес-событию `NewTaskPublished`
- Начисление бонусов при успешном выполнении задания должно происходить посредством асинхронной функциональной связи, по бизнес-событию `TaskCompletedSuccessfully`.
- Списание бонусов при неудачном выполнении задания должно происходить посредством асинхронной функциональной связи, по бизнес-событию `TaskFailed`.

#### 4.1. Проблемы продюсера

1. В бизнес-логике процесса создания нового задания есть вызов внешней системы через HTTP API.  
  Если этот вызов делать в рамках той же бизнес-транзакции, что и отправка события, то транзакция может откатиться, если вызов API завершится неудачно.  
  Для сценария начисления за успешное выполнение задания - ситуация похожая: по какой-то причине может упасть логика промоута кандидата до звания "Учитель".  
  Чтобы не послать консюмеру событие, которое не произошло в системе, можно использовать подход **Transactional outbox**: вместо прямой отправки события в брокер - информация о событии заносится в отдельную таблицу БД, данные попадут в таблицу только на успешном коммите всей транзакции.

2. Брокер недоступен в момент отправки события.  
    - Настроим ack с подтверждением, что брокер получил событие.
    - Добавим retry с экспоненциальным backoff, если вдруг не получили подтверждение.  
    - Настроим алерты в мониторинге, следить за жизнью кафки.

#### 4.2. Проблемы консюмера

1. Событие не пришло, или пришло несколько одинаковых  
  Настроим гарантии доставки - **At-least-once delivery**.  
  Таким образом, возможна ситуация, когда событие придет несколько раз (exactly once не гарантируется).  
  В таком случае консюмер должен быть готов идемпотентно обработать событие: посмотрим на связку `event_id` + `produced_at`, проигнорируем дубликаты.

2. Событие не соответствует ожиданиям консюмера или бизнес-логика упала  
    - Это возможно в нескольких случаях:  
      - Событие не валидируется по схеме из registry (криво накатили обновление).
      - Для сценария начисления по успешному выполнению задания - если мы пошли синхронно доставть Рейтинг задания через `GET`-запрос - он может упасть и обвалить транзакцию.  

    - Что будем делать:  
      - Отправим событие в DLQ.  
      - "Сурьёзный Бизьнесь" обожает AI - поэтому подключение `CatТыгыдык` к DLQ вообще обязательно к применению в 2к26, ведь очевидно же что он решит все проблемы, моментально и за бесплатно.
